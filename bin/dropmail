#!/usr/bin/perl
## ----------------------------------------------------------------------------

use strict;
use warnings;
use File::Basename;
use File::Copy;
use File::Slurp;
use JSON::Any;
use MIME::Lite;
use Log::Log4perl qw(get_logger);

## ----------------------------------------------------------------------------
# constants, setup and initialisation

my $VERSION = '0.2.0';

my $basedir = q{/var/cache/dropmail};

Log::Log4perl::init('/etc/dropmail.conf');
my $log = get_logger();

## ----------------------------------------------------------------------------

{
    $log->info( q{-} x 79 );
    $log->info( q{Started} );

    my @filenames = <$basedir/*.json>;

    # just get the file names themselves
    @filenames = map { basename $_ } @filenames;

    # move them all to the 'processing' directory
    $log->info( q{Files found: } . (scalar @filenames) );
    foreach my $filename ( @filenames ) {
        mv_to_processing( $filename );
    }

    # read each file in as a hash
    foreach my $filename ( @filenames ) {
        $log->info( qq{Reading file '$filename'} );

        my $file = read_file( qq{$basedir/.processing/$filename} );
        my $email = eval { JSON::Any->jsonToObj( $file ) };
        if ( $@ ) {
            # couldn't parse
            mv_to_failed( $filename, qq{$filename couldn't parse as JSON: $@} );
            next;
        }

        unless ( ref $email eq 'HASH' ) {
            # not a hash
            mv_to_failed( $filename, qq{$filename data structure is not a hash} );
            next;
        }

        eval { send_email($email); };
        if ( $@ ) {
            # couldn't send
            mv_to_failed( $filename, qq{$filename couldn't be sent: $@} );
            next;
        }

        # this file was processed correctly
        mv_to_done( $filename );
    }

    $log->info( q{Finished} );
    $log->info( q{-} x 79 );
}

## ----------------------------------------------------------------------------

sub mv_to_processing {
    my ($filename) = @_;
    $log->debug( qq{Moving to processing: $filename} );
    move( qq{$basedir/$filename}, qq{$basedir/.processing/} );
}

sub mv_to_failed {
    my ($filename, $msg) = @_;
    $log->warn( $msg );
    $log->info( qq{Moving to failed: $filename} );
    move( qq{$basedir/.processing/$filename}, qq{$basedir/.failed/} );
}

sub mv_to_done {
    my ($filename) = @_;
    $log->info( qq{Moving to done: $filename} );
    move( qq{$basedir/.processing/$filename}, qq{$basedir/.done/} );
}

## ----------------------------------------------------------------------------

sub send_email {
    my ($email) = @_;

    # the things we need:
    # * from
    # * to (required, a scalar or an array of addresses)
    # * cc (optional, a scalar or an array of addresses)
    # * bcc (optional, a scalar or an array of addresses)
    # * copy_self (optional default false, boolean, will copy 'from' address to the 'bcc' address(es))
    # * subject (optional, string, default 'No Subject')
    # * text (required, string)
    # * html (optional, string
    # * ToDo: attachments

    unless ( defined $email->{to} ) {
        # log a warning
        die "No 'to' given";
    }

    unless ( defined $email->{from} ) {
        # log a warning
        die "No 'from' given";
    }

    unless ( defined $email->{text} ) {
        # log a warning
        die "No 'text' given";
    }

    $email->{copy_self} //= 0;
    $email->{subject} //= '[No Subject]';

    # tidy up some inputs so we know what we have
    if ( ref $email->{to} ne 'ARRAY' ) {
        $email->{to} = [ $email->{to} ];
    }
    if ( defined $email->{cc} and ref $email->{cc} ne 'ARRAY' ) {
        $email->{cc} = [ $email->{cc} ];
    }
    if ( defined $email->{bcc} and ref $email->{bcc} ne 'ARRAY' ) {
        $email->{bcc} = [ $email->{bcc} ];
    }

    my $msg;
    if ( defined $email->{html} ) {
        $msg = MIME::Lite->new(
            Type    => 'multipart/alternative',
        );
        # attach the plain text
        $msg->attach(
            Type    => q{text/plain; utf-8},
            Data    => $email->{text},
        );
        $msg->attach(
            Type    => q{text/html; utf-8},
            Data    => $email->{html},
        );
    }
    else {
        # just send a normal text message
        $msg = MIME::Lite->new(
            Data     => $email->{text},
        );
    }

    # copy this email to self if wanted
    if ( $email->{copy_self} ) {
        push @{$email->{bcc}}, $email->{from};
    }

    # do the required headers
    foreach my $hdr ( qw(from subject) ) {
        $msg->add($hdr, $email->{$hdr} );
    }

    # do the headers which can be from lists
    foreach my $hdr ( qw( to cc bcc ) ) {
        next unless defined $email->{$hdr};
        $msg->add( $hdr, _flatten($email->{$hdr}) );
    }

    # ToDo: attachments
    # do any attachments we might have
    # foreach my $attachment ( @{$email->{attachments}} ) {
    #     $msg->attach( %$attachment );
    # }

    # put our own X-Mailer header on the email
    $msg->replace( q{x-mailer}, q{DropMail - http://www.github.com/appsattic/dropmail} );

    # finally, send the message
    $msg->send();
}

sub _flatten {
    my ($thing) = @_;

    return unless defined $thing;

    if ( ref $thing eq 'ARRAY' ) {
        return join( ', ', @$thing );
    }
    elsif ( ref $thing ) {
        # not sure what to do with other references, so stringify it
        return "$thing";
    }

    # else, just a scalar
    return $thing;
}

## ----------------------------------------------------------------------------
